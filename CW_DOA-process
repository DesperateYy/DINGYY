import numpy as np
import plotly.graph_objects as go
from scipy.io import loadmat
from scipy.linalg import solve

# --- 1. 参数设置 (必须与采集脚本和硬件一致) ---
DATA_FILE = "tma_data_cw_2ghz.mat"  # 对应采集脚本的输出文件名
SWITCHING_FREQ = 10e3  # 10 kHz (TMA 开关频率)
ANTENNA_D = 0.05  # 【关键】5厘米间距 (2GHz 下必须 < 7.5cm，5cm是安全的)
C = 3e8  # 光速

if __name__ == "__main__":
    print(f"--- CW Processing & DOA (Target: 2 GHz, d={ANTENNA_D}m) ---")

    # --- 2. 加载数据 ---
    try:
        mat = loadmat(DATA_FILE)
        tma = mat['tma_signal_raw'].flatten()
        ref = mat['ref_signal_raw'].flatten()

        # 尝试从文件中读取配置 (增强鲁棒性)
        try:
            cfg = mat['config'][0, 0]
            fs = float(cfg['sample_rate'].item())
            f0 = float(cfg['center_freq'].item())
        except:
            # 如果读取失败，使用默认值
            fs = 10e4
            f0 = 2e9
            print("⚠️ Warning: Could not read config from file, using defaults (fs=100k, f0=2G)")

        print(f"✅ Data loaded successfully.")
        print(f"   Sample Rate: {fs / 1e3:.1f} kHz")
        print(f"   Center Freq: {f0 / 1e9:.3f} GHz")

    except FileNotFoundError:
        print(f"❌ Error: File '{DATA_FILE}' not found. Please run the acquisition script first.")
        exit()
    except Exception as e:
        print(f"❌ Error loading data: {e}")
        exit()

    # --- 3. 核心算法：解调/去载波 ---
    # 原理：y = x_TMA(t) * conj(x_Ref(t))
    # 对于 CW 信号，x_Ref(t) ≈ exp(j(ωt + φ_err))
    # 乘以共轭后，e^(jωt) 被抵消，只留下 TMA 引入的周期性调制项
    print("▶️  Performing Demodulation (y = tma * conj(ref))...")
    y_pc = tma * np.conj(ref)

    # --- 4. 绘图验证：解调后的频谱 ---
    # 预期：
    # 1. 0Hz 处有一个尖峰 (直流分量)
    # 2. ±10kHz, ±20kHz... 处有尖峰 (开关谐波)
    # 3. 尖峰应该非常锐利，且高出噪声基底
    print("▶️  Generating verification plot...")
    M = len(y_pc)
    freqs = np.fft.fftshift(np.fft.fftfreq(M, d=1 / fs))
    spec_pc = np.fft.fftshift(np.fft.fft(y_pc))
    spec_db = 20 * np.log10(np.abs(spec_pc) + 1e-12)

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=freqs / 1e3, y=spec_db, mode='lines', name='Processed Spectrum'))
    fig.update_layout(
        title="Spectrum After Demodulation (Expect Sharp Harmonic Peaks)",
        xaxis_title="Frequency Offset (kHz)",
        yaxis_title="Power (dB)",
        template="plotly_white"
    )
    # 限制显示范围在 ±50kHz
    fig.update_xaxes(range=[-50, 50])
    fig.show()

    # --- 5. DOA 测角算法 ---
    print("▶️  Calculating Direction of Arrival (DOA)...")

    # A. 提取谐波复数值
    # 提取 0, ±10k, ±20k... 处的复数
    n_harmonics = 5
    target_freqs = np.arange(-n_harmonics, n_harmonics + 1) * SWITCHING_FREQ

    Y_raw = np.fft.fft(y_pc) / M
    freqs_raw = np.fft.fftfreq(M, d=1 / fs)

    tildeY = []
    for f_target in target_freqs:
        # 寻找最近的频点索引
        idx = np.argmin(np.abs(freqs_raw - f_target))
        tildeY.append(Y_raw[idx])
    tildeY = np.array(tildeY)


    # B. 构建系统矩阵 (M Matrix)
    # 模拟 10kHz 互补开关的理论系数
    def get_switch_coeffs(N_harmonics):
        T_sim = 1.0
        dt = 0.001
        t = np.arange(0, T_sim, dt)

        # 50% 占空比互补开关
        sw1 = ((t >= 0) & (t < 0.5)).astype(float)
        sw2 = ((t >= 0.5) & (t < 1.0)).astype(float)

        S1 = np.fft.fft(sw1) / len(t)
        S2 = np.fft.fft(sw2) / len(t)
        freqs_sim = np.fft.fftfreq(len(t), d=dt)

        coeffs = np.zeros((2 * N_harmonics + 1, 2), dtype=complex)
        for i, k in enumerate(range(-N_harmonics, N_harmonics + 1)):
            idx = np.argmin(np.abs(freqs_sim - k))
            coeffs[i, 0] = S1[idx]
            coeffs[i, 1] = S2[idx]
        return coeffs


    M_matrix = get_switch_coeffs(n_harmonics)

    # C. 求解天线系数 (a_hat)
    # tildeY = M * a_hat  =>  a_hat = pinv(M) * tildeY
    a_hat = np.linalg.pinv(M_matrix) @ tildeY

    # D. 计算相位差 & 反解角度
    phase_diff = np.angle(a_hat[1]) - np.angle(a_hat[0])

    # 归一化到 -pi ~ pi
    phase_diff = (phase_diff + np.pi) % (2 * np.pi) - np.pi

    # theta = arcsin( (phase_diff * c) / (2 * pi * f0 * d) )
    val = (phase_diff * C) / (2 * np.pi * f0 * ANTENNA_D)

    # 安全裁剪
    val = np.clip(val, -1.0, 1.0)

    theta_rad = np.arcsin(val)
    theta_deg = np.degrees(theta_rad)

    # --- 6. 输出结果 ---
    print("\n" + "=" * 45)
    print(f"RESULTS (CW Signal, 2 GHz, d={ANTENNA_D * 100:.1f}cm)")
    print("-" * 45)
    print(f"Calculated Phase Difference : {np.degrees(phase_diff):.3f}°")
    print(f"Estimated DOA Angle         : {theta_deg:.3f}°")
    print("=" * 45 + "\n")
