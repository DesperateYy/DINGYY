import numpy as np
import plotly.graph_objects as go
from scipy.io import loadmat
from scipy.linalg import solve

# --- 1. 参数设置 (必须与采集脚本和物理硬件一致) ---
DATA_FILE = "captured_tma_data_2ghz.mat"  # 对应采集脚本的输出文件名
SWITCHING_FREQ = 10e3  # 10 kHz (TMA 开关频率)
ANTENNA_D = 0.05  # 【关键】5厘米间距 (物理测量值，需 < 7.5cm)
C = 3e8  # 光速

if __name__ == "__main__":
    print(f"--- TMA Processing & DOA Estimation (Target: 2 GHz, d={ANTENNA_D}m) ---")

    # --- 2. 加载数据 ---
    try:
        mat = loadmat(DATA_FILE)
        # Flatten 将数组展平，防止维度问题
        tma = mat['tma_signal_raw'].flatten()
        ref = mat['ref_signal_raw'].flatten()

        # 尝试从文件中读取配置，如果失败则使用默认值 (增强鲁棒性)
        try:
            cfg = mat['config'][0, 0]
            fs = float(cfg['sample_rate'].item())
            f0 = float(cfg['center_freq'].item())
        except:
            fs = 10e4
            f0 = 2e9
            print("⚠️ Warning: Could not read config from file, using defaults (fs=100k, f0=2G)")

        print(f"✅ Data loaded successfully.")
        print(f"   Sample Rate: {fs / 1e3:.1f} kHz")
        print(f"   Center Freq: {f0 / 1e9:.3f} GHz")

    except FileNotFoundError:
        print(f"❌ Error: File '{DATA_FILE}' not found. Please run the acquisition script first.")
        exit()
    except Exception as e:
        print(f"❌ Error loading data: {e}")
        exit()

    # --- 3. 核心算法：脉冲压缩 ---
    # 原理：TMA信号 乘以 参考信号的共轭 (去Chirp，还原单频谐波)
    print("▶️  Performing Pulse Compression (y = tma * conj(ref))...")
    y_pc = tma * np.conj(ref)

    # --- 4. 绘图验证：脉冲压缩后的频谱 ---
    # 预期：原本宽带的信号应该变成了 0Hz, ±10kHz, ±20kHz... 处的一系列尖峰
    print("▶️  Generating verification plot...")
    M = len(y_pc)
    freqs = np.fft.fftshift(np.fft.fftfreq(M, d=1 / fs))
    spec_pc = np.fft.fftshift(np.fft.fft(y_pc))
    spec_db = 20 * np.log10(np.abs(spec_pc) + 1e-12)

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=freqs / 1e3, y=spec_db, mode='lines', name='Pulse Compressed'))
    fig.update_layout(
        title="Spectrum After Pulse Compression (Verification)",
        xaxis_title="Frequency Offset (kHz)",
        yaxis_title="Power (dB)",
        template="plotly_white"
    )
    # 限制显示范围在 ±50kHz，方便观察谐波结构
    fig.update_xaxes(range=[-50, 50])
    fig.show()

    # --- 5. DOA 测角算法 ---
    print("▶️  Calculating Direction of Arrival (DOA)...")

    # A. 提取谐波复数值
    # 我们需要提取 0, ±10k, ±20k... 处的复数值
    n_harmonics = 5
    target_freqs = np.arange(-n_harmonics, n_harmonics + 1) * SWITCHING_FREQ

    Y_raw = np.fft.fft(y_pc) / M  # 归一化FFT
    freqs_raw = np.fft.fftfreq(M, d=1 / fs)

    tildeY = []
    for f_target in target_freqs:
        # 在FFT结果中找到距离目标频率最近的点 (鲁棒性更好)
        idx = np.argmin(np.abs(freqs_raw - f_target))
        tildeY.append(Y_raw[idx])
    tildeY = np.array(tildeY)


    # B. 构建系统矩阵 (M Matrix)
    # 模拟开关的理论谐波系数
    def get_switch_coeffs(N_harmonics):
        T_sim = 1.0
        dt = 0.001
        t = np.arange(0, T_sim, dt)

        # 互补开关时序：Ant1前半周期，Ant2后半周期
        sw1 = ((t >= 0) & (t < 0.5)).astype(float)
        sw2 = ((t >= 0.5) & (t < 1.0)).astype(float)

        S1 = np.fft.fft(sw1) / len(t)
        S2 = np.fft.fft(sw2) / len(t)
        freqs_sim = np.fft.fftfreq(len(t), d=dt)

        coeffs = np.zeros((2 * N_harmonics + 1, 2), dtype=complex)
        for i, k in enumerate(range(-N_harmonics, N_harmonics + 1)):
            idx = np.argmin(np.abs(freqs_sim - k))
            coeffs[i, 0] = S1[idx]
            coeffs[i, 1] = S2[idx]
        return coeffs


    M_matrix = get_switch_coeffs(n_harmonics)

    # C. 求解天线系数 (a_hat)
    # tildeY = M_matrix * a_hat  -->  a_hat = pinv(M) * tildeY
    a_hat = np.linalg.pinv(M_matrix) @ tildeY

    # D. 计算相位差
    # 两个系数的相位差就是空间相位差
    phase_diff = np.angle(a_hat[1]) - np.angle(a_hat[0])

    # 将相位归一化到 -pi 到 +pi 之间
    phase_diff = (phase_diff + np.pi) % (2 * np.pi) - np.pi

    # E. 反解角度 (theta)
    # sin(theta) = (phase_diff * c) / (2 * pi * f0 * d)
    val = (phase_diff * C) / (2 * np.pi * f0 * ANTENNA_D)

    # 安全裁剪，防止因噪声导致的数值溢出 (sin值 > 1)
    val = np.clip(val, -1.0, 1.0)

    theta_rad = np.arcsin(val)
    theta_deg = np.degrees(theta_rad)

    # --- 6. 输出结果 ---
    print("\n" + "=" * 40)
    print(f"RESULTS (f0={f0 / 1e9:.2f}G, d={ANTENNA_D * 100:.1f}cm)")
    print("-" * 40)
    print(f"Calculated Phase Difference : {np.degrees(phase_diff):.3f}°")
    print(f"Estimated DOA Angle         : {theta_deg:.3f}°")
    print("=" * 40 + "\n")
