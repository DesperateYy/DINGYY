import uhd
import numpy as np
import threading
from scipy.io import savemat
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# --- 1. 配置参数 ---
config = {
    "center_freq": 1e9,  # 中心频率 2 GHz
    "sample_rate": 10e4,  # 采样率 100 kHz
    "tx_gain": 60,  # 发射增益 (您可以根据实际信号质量微调)
    "rx_gain": 60,  # 接收增益 (您可以根据实际信号质量微调)
    "duration": 1.0,  # 采集1秒数据
    "tx_chan": [0, 1],  # 2T2R模式
    "rx_chan": [0, 1],  # 2T2R模式

    "tx_amp": 0.7,
    # 【修改】移除了Chirp参数
    "output_filename": "captured_tma_data_cw_2ghz.mat"  # 【修改】输出文件名
}

# 【修改】不再需要build_chirp函数


if __name__ == "__main__":
    print(f"--- Data Acquisition Script (CW / Sine Wave) @ 2 GHz ---")
    print(f"Center Frequency: {config['center_freq'] / 1e9:.1f} GHz")
    print(f"Sampling Rate: {config['sample_rate'] / 1e3:.1f} kHz")
    print(f"Will save data to: {config['output_filename']}")

    # SDR初始化和连续流收发的代码
    usrp = uhd.usrp.MultiUSRP()
    for chan in config['tx_chan']: usrp.set_tx_rate(float(config["sample_rate"]), chan); usrp.set_tx_freq(
        uhd.libpyuhd.types.tune_request(float(config["center_freq"])), chan); usrp.set_tx_gain(float(config["tx_gain"]),
                                                                                               chan)
    for chan in config['rx_chan']: usrp.set_rx_rate(float(config["sample_rate"]), chan); usrp.set_rx_freq(
        uhd.libpyuhd.types.tune_request(float(config["center_freq"])), chan); usrp.set_rx_gain(float(config["rx_gain"]),
                                                                                               chan)
    tx_args = uhd.usrp.StreamArgs("fc32", "sc16");
    tx_args.channels = config['tx_chan'];
    tx_streamer = usrp.get_tx_stream(tx_args)
    rx_args = uhd.usrp.StreamArgs("fc32", "sc16");
    rx_args.channels = config['rx_chan'];
    rx_streamer = usrp.get_rx_stream(rx_args)

    # 【修改】生成一个纯CW（正弦波）信号
    # 在基带，纯正弦波就是一个直流(DC)复数值
    tx_frame_buffer_size = 4096  # 流式传输的缓冲区大小
    tx_frame = np.full(tx_frame_buffer_size, config["tx_amp"] * (1.0 + 0.0j), dtype=np.complex64)

    tx_wave = np.zeros((2, len(tx_frame)), dtype=np.complex64);
    tx_wave[0, :] = tx_frame  # 只在TRXA上发射

    stream_cmd = uhd.types.StreamCMD(uhd.types.StreamMode.start_cont);
    stream_cmd.stream_now = False;
    stream_cmd.time_spec = usrp.get_time_now() + uhd.types.TimeSpec(0.1);
    rx_streamer.issue_stream_cmd(stream_cmd)
    stop_sending = threading.Event()


    def continuous_send():
        tx_md = uhd.types.TXMetadata();
        tx_md.start_of_burst = False;
        tx_md.has_time_spec = True;
        tx_md.time_spec = stream_cmd.time_spec
        first_packet = True
        while not stop_sending.is_set():
            tx_streamer.send(tx_wave, tx_md)
            if first_packet: tx_md.has_time_spec = False; first_packet = False


    send_thread = threading.Thread(target=continuous_send);
    send_thread.start()
    num_samps_to_recv = int(config["duration"] * config["sample_rate"]);
    rx_buffer = np.zeros((2, num_samps_to_recv), dtype=np.complex64)
    print(f"▶️  Receiving {num_samps_to_recv} samples on 2 channels...")
    samples_received = rx_streamer.recv(rx_buffer, uhd.types.RXMetadata(), config["duration"] + 1.0)
    stop_sending.set();
    send_thread.join()
    rx_streamer.issue_stream_cmd(uhd.types.StreamCMD(uhd.types.StreamMode.stop_cont))
    print(f"✅  Acquisition complete. Received {samples_received} samples.")

    tma_signal = rx_buffer[0, :samples_received]  # RXA (TMA)
    ref_signal = rx_buffer[1, :samples_received]  # RXB (Reference)

    # --- 实时验证绘图 ---
    if len(ref_signal) > 0 and len(tma_signal) > 0:
        print("▶️  Plotting live verification spectra...")
        fig = make_subplots(rows=2, cols=1,
                            subplot_titles=("Spectrum on RXB (Reference Channel)", "Spectrum on RXA (TMA Channel)"))

        # 预期：RXB应该是一个在0Hz处非常尖锐的峰值（可能有小的频偏）
        NFFT_ref = len(ref_signal);
        fft_ref = np.fft.fftshift(np.fft.fft(ref_signal));
        fft_freq_ref = np.fft.fftshift(np.fft.fftfreq(NFFT_ref, d=1 / config["sample_rate"]));
        fft_db_ref = 20 * np.log10(np.abs(fft_ref) + 1e-12)
        fig.add_trace(go.Scatter(x=fft_freq_ref / 1e3, y=fft_db_ref, mode='lines', name='Reference Spectrum'), row=1,
                      col=1)

        # 预期：RXA应该是0Hz, ±10kHz, ±30kHz... 处的尖锐峰值
        NFFT_tma = len(tma_signal);
        fft_tma = np.fft.fftshift(np.fft.fft(tma_signal));
        fft_freq_tma = np.fft.fftshift(np.fft.fftfreq(NFFT_tma, d=1 / config["sample_rate"]));
        fft_db_tma = 20 * np.log10(np.abs(fft_tma) + 1e-12)
        fig.add_trace(go.Scatter(x=fft_freq_tma / 1e3, y=fft_db_tma, mode='lines', name='TMA Spectrum'), row=2, col=1)

        fig.update_layout(height=800, title_text="Live Verification of Acquired Signals (CW @ 2 GHz)", showlegend=False)
        fig.update_xaxes(title_text="Frequency Offset (kHz)",
                         range=[-config["sample_rate"] / 2 / 1e3, config["sample_rate"] / 2 / 1e3], row=1, col=1)
        fig.update_xaxes(title_text="Frequency Offset (kHz)",
                         range=[-config["sample_rate"] / 2 / 1e3, config["sample_rate"] / 2 / 1e3], row=2, col=1)
        fig.update_yaxes(title_text="Power (dB)", row=1, col=1);
        fig.update_yaxes(title_text="Power (dB)", row=2, col=1)
        fig.show()

    # --- 保存数据 ---
    print(f"▶️  Saving data to {config['output_filename']}...")
    save_dict = {"tma_signal_raw": tma_signal, "ref_signal_raw": ref_signal, "config": config}
    savemat(config['output_filename'], save_dict)
    print(f"✅  Data saved successfully.")
