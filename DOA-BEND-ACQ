import uhd
import numpy as np
import threading
from scipy.io import savemat
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# --- 1. 配置参数 ---
config = {
    "center_freq": 2e9,       # 【修改】中心频率 2 GHz
    "sample_rate": 10e4,      # 采样率 100 kHz (维持之前成功观察到调制效果的设置)
    "tx_gain": 70,            # 发射增益 (您可以根据实际信号质量微调)
    "rx_gain": 60,            # 接收增益 (您可以根据实际信号质量微调)
    "duration": 1.0,          # 采集1秒数据
    "tx_chan": [0, 1],        # 2T2R模式
    "rx_chan": [0, 1],        # 2T2R模式

    "tx_amp": 0.7,
    "chirp_f0": -0.3e4,       # Chirp起始频率 -3 kHz (维持之前设置)
    "chirp_f1": +0.3e4,       # Chirp终止频率 +3 kHz (维持之前设置)
    "num_samps_per_frame": 8192,
    "output_filename": "captured_tma_data_2ghz.mat" # 【修改】输出文件名
}


# build_chirp 函数 (与之前完全相同)
def build_chirp(cfg):
    num_samps = int(cfg["num_samps_per_frame"]);
    fs = float(cfg["sample_rate"]);
    f0 = float(cfg["chirp_f0"]);
    f1 = float(cfg["chirp_f1"]);
    amp = float(cfg["tx_amp"])
    n = np.arange(num_samps, dtype=np.float64);
    T = num_samps / fs;
    k = (f1 - f0) / T;
    t = n / fs
    phase = 2 * np.pi * (f0 * t + 0.5 * k * t * t)
    return (amp * np.exp(1j * phase)).astype(np.complex64)


if __name__ == "__main__":
    print(f"--- Data Acquisition Script with Live Verification (2 GHz) ---")
    print(f"Center Frequency: {config['center_freq']/1e9:.1f} GHz")
    print(f"Sampling Rate: {config['sample_rate']/1e3:.1f} kHz")
    print(f"Chirp Bandwidth: {(config['chirp_f1'] - config['chirp_f0'])/1e3:.1f} kHz")
    print(f"Will save data to: {config['output_filename']}")

    # SDR初始化和连续流收发的代码 (与之前完全相同)
    usrp = uhd.usrp.MultiUSRP()
    for chan in config['tx_chan']: usrp.set_tx_rate(float(config["sample_rate"]), chan); usrp.set_tx_freq(
        uhd.libpyuhd.types.tune_request(float(config["center_freq"])), chan); usrp.set_tx_gain(float(config["tx_gain"]),
                                                                                               chan)
    for chan in config['rx_chan']: usrp.set_rx_rate(float(config["sample_rate"]), chan); usrp.set_rx_freq(
        uhd.libpyuhd.types.tune_request(float(config["center_freq"])), chan); usrp.set_rx_gain(float(config["rx_gain"]),
                                                                                               chan)
    tx_args = uhd.usrp.StreamArgs("fc32", "sc16");
    tx_args.channels = config['tx_chan'];
    tx_streamer = usrp.get_tx_stream(tx_args)
    rx_args = uhd.usrp.StreamArgs("fc32", "sc16");
    rx_args.channels = config['rx_chan'];
    rx_streamer = usrp.get_rx_stream(rx_args)
    tx_frame = build_chirp(config);
    tx_wave = np.zeros((2, len(tx_frame)), dtype=np.complex64);
    tx_wave[0, :] = tx_frame
    stream_cmd = uhd.types.StreamCMD(uhd.types.StreamMode.start_cont);
    stream_cmd.stream_now = False;
    stream_cmd.time_spec = usrp.get_time_now() + uhd.types.TimeSpec(0.1);
    rx_streamer.issue_stream_cmd(stream_cmd)
    stop_sending = threading.Event()


    def continuous_send():
        tx_md = uhd.types.TXMetadata();
        tx_md.start_of_burst = False;
        tx_md.has_time_spec = True;
        tx_md.time_spec = stream_cmd.time_spec
        first_packet = True
        while not stop_sending.is_set():
            tx_streamer.send(tx_wave, tx_md)
            if first_packet: tx_md.has_time_spec = False; first_packet = False


    send_thread = threading.Thread(target=continuous_send);
    send_thread.start()
    num_samps_to_recv = int(config["duration"] * config["sample_rate"]);
    rx_buffer = np.zeros((2, num_samps_to_recv), dtype=np.complex64)
    print(f"▶️  Receiving {num_samps_to_recv} samples on 2 channels...")
    samples_received = rx_streamer.recv(rx_buffer, uhd.types.RXMetadata(), config["duration"] + 1.0)
    stop_sending.set();
    send_thread.join()
    rx_streamer.issue_stream_cmd(uhd.types.StreamCMD(uhd.types.StreamMode.stop_cont))
    print(f"✅  Acquisition complete. Received {samples_received} samples.")

    tma_signal = rx_buffer[0, :samples_received] # RXA (TMA)
    ref_signal = rx_buffer[1, :samples_received] # RXB (Reference)

    # --- 实时验证绘图 ---
    if len(ref_signal) > 0 and len(tma_signal) > 0:
        print("▶️  Plotting live verification spectra...")
        fig = make_subplots(rows=2, cols=1,
                            subplot_titles=("Spectrum on RXB (Reference Channel)", "Spectrum on RXA (TMA Channel)"))
        NFFT_ref = len(ref_signal); fft_ref = np.fft.fftshift(np.fft.fft(ref_signal)); fft_freq_ref = np.fft.fftshift(np.fft.fftfreq(NFFT_ref, d=1 / config["sample_rate"])); fft_db_ref = 20 * np.log10(np.abs(fft_ref) + 1e-12)
        fig.add_trace(go.Scatter(x=fft_freq_ref / 1e3, y=fft_db_ref, mode='lines', name='Reference Spectrum'), row=1, col=1)
        NFFT_tma = len(tma_signal); fft_tma = np.fft.fftshift(np.fft.fft(tma_signal)); fft_freq_tma = np.fft.fftshift(np.fft.fftfreq(NFFT_tma, d=1 / config["sample_rate"])); fft_db_tma = 20 * np.log10(np.abs(fft_tma) + 1e-12)
        fig.add_trace(go.Scatter(x=fft_freq_tma / 1e3, y=fft_db_tma, mode='lines', name='TMA Spectrum'), row=2, col=1)
        fig.update_layout(height=800, title_text="Live Verification of Acquired Signals (2 GHz)", showlegend=False)
        fig.update_xaxes(title_text="Frequency Offset (kHz)", range=[-config["sample_rate"]/2/1e3, config["sample_rate"]/2/1e3], row=1, col=1)
        fig.update_xaxes(title_text="Frequency Offset (kHz)", range=[-config["sample_rate"]/2/1e3, config["sample_rate"]/2/1e3], row=2, col=1)
        fig.update_yaxes(title_text="Power (dB)", row=1, col=1); fig.update_yaxes(title_text="Power (dB)", row=2, col=1)
        fig.show()

    # --- 保存数据 ---
    print(f"▶️  Saving data to {config['output_filename']}...")
    save_dict = { "tma_signal_raw": tma_signal, "ref_signal_raw": ref_signal, "config": config }
    savemat(config['output_filename'], save_dict)
    print(f"✅  Data saved successfully.")
